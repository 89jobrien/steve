---
name: session-summary
description: Generate markdown summary of what was accomplished in the session when stopping.
author: Joseph OBrien
status: unpublished
updated: 2025-12-23
version: 1.0.1
tag: hook
---
# Session Summary

```python
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///

"""
Generate markdown summary of what was accomplished in the session when stopping.

This hook creates a summary of the session's activities.
Runs on Stop event.
"""

import json
import os
import sys
from datetime import datetime
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))
from hook_logging import hook_invocation


def get_summary_dir() -> Path:
    """Get the directory for session summaries."""
    summary_dir = Path.home() / ".claude" / "session-summaries"
    summary_dir.mkdir(parents=True, exist_ok=True)
    return summary_dir


def analyze_transcript(transcript_path: str) -> dict:
    """Analyze transcript to extract key information."""
    path = Path(transcript_path)
    if not path.exists():
        return {}

    try:
        content = path.read_text()
    except (OSError, UnicodeDecodeError):
        return {}

    # Count different activities
    stats = {
        "files_written": content.count('"tool_name": "Write"'),
        "files_edited": content.count('"tool_name": "Edit"')
        + content.count('"tool_name": "MultiEdit"'),
        "commands_run": content.count('"tool_name": "Bash"'),
        "searches": content.count('"tool_name": "Grep"')
        + content.count('"tool_name": "Glob"'),
        "reads": content.count('"tool_name": "Read"'),
    }

    # Extract file paths mentioned
    import re

    file_paths = set(re.findall(r'"file_path":\s*"([^"]+)"', content))
    stats["files_touched"] = list(file_paths)[:20]  # Limit to 20

    return stats


def generate_summary(stats: dict, cwd: str) -> str:
    """Generate markdown summary."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    summary = f"""# Session Summary

**Date:** {timestamp}
**Working Directory:** {cwd}

## Activity Overview

| Metric | Count |
|--------|-------|
| Files Written | {stats.get("files_written", 0)} |
| Files Edited | {stats.get("files_edited", 0)} |
| Commands Run | {stats.get("commands_run", 0)} |
| Searches | {stats.get("searches", 0)} |
| Files Read | {stats.get("reads", 0)} |

## Files Touched

"""

    files = stats.get("files_touched", [])
    if files:
        for f in files:
            summary += f"- `{f}`\n"
    else:
        summary += "_No files tracked_\n"

    summary += """
## Notes

_Add your own notes about this session here_

---
*Generated by session_summary hook*
"""

    return summary


def main() -> None:
    with hook_invocation("session_summary") as inv:
        try:
            payload = json.load(sys.stdin)
        except json.JSONDecodeError:
            sys.exit(0)

        inv.set_payload(payload)

        if payload.get("stop_hook_active"):
            sys.exit(0)

        transcript_path = payload.get("transcript_path", "")
        cwd = payload.get("cwd", ".")

        # Analyze the session
        stats = analyze_transcript(transcript_path) if transcript_path else {}

        # Skip if minimal activity
        total_activity = sum(
            [
                stats.get("files_written", 0),
                stats.get("files_edited", 0),
                stats.get("commands_run", 0),
            ]
        )

        if total_activity < 3:
            # Not enough activity to warrant a summary
            sys.exit(0)

        # Generate summary
        summary = generate_summary(stats, cwd)

        # Save summary
        summary_dir = get_summary_dir()
        session_id = os.environ.get("CLAUDE_SESSION_ID", str(os.getpid()))
        date_str = datetime.now().strftime("%Y%m%d_%H%M%S")

        summary_path = summary_dir / f"summary_{date_str}_{session_id}.md"

        try:
            summary_path.write_text(summary)
            print(
                f"[Success] Session summary saved to {summary_path.name}",
                file=sys.stderr,
            )
        except OSError as e:
            print(f"[Warning] Failed to save summary: {e}", file=sys.stderr)

        sys.exit(0)


if __name__ == "__main__":
    main()
```
